<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.3.3" /><meta property="og:title" content="MIT 6.858 Course 2 - Control Hijacking Attacks" /><meta property="og:locale" content="en" /><meta name="description" content="缓冲区溢出的根本原因？" /><meta property="og:description" content="缓冲区溢出的根本原因？" /><link rel="canonical" href="https://linhongbo.com/posts/mit-6858-course-2-control-hijacking-attacks/" /><meta property="og:url" content="https://linhongbo.com/posts/mit-6858-course-2-control-hijacking-attacks/" /><meta property="og:site_name" content="Hongbo Lin" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-11-26T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="MIT 6.858 Course 2 - Control Hijacking Attacks" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-11-26T00:00:00+08:00","datePublished":"2021-11-26T00:00:00+08:00","description":"缓冲区溢出的根本原因？","headline":"MIT 6.858 Course 2 - Control Hijacking Attacks","mainEntityOfPage":{"@type":"WebPage","@id":"https://linhongbo.com/posts/mit-6858-course-2-control-hijacking-attacks/"},"url":"https://linhongbo.com/posts/mit-6858-course-2-control-hijacking-attacks/"}</script><title>MIT 6.858 Course 2 - Control Hijacking Attacks | Hongbo Lin</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Hongbo Lin"><meta name="application-name" content="Hongbo Lin"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Hongbo Lin</a></div><div class="site-subtitle font-italic">A technology-focused blogger.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/alhongb" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['example','doamin.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>MIT 6.858 Course 2 - Control Hijacking Attacks</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>MIT 6.858 Course 2 - Control Hijacking Attacks</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Hongbo Lin </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Nov 26, 2021, 12:00 AM +0800" >Nov 26, 2021<i class="unloaded">2021-11-26T00:00:00+08:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2970 words">16 min read</span></div></div><div class="post-content"><h2 id="缓冲区溢出的根本原因">缓冲区溢出的根本原因？</h2><ol><li>系统软件大多是 C 写的，C 速度快、接近硬件…，而 C 暴露 raw memory 且没有边界检查<li>对 x86 架构的了解：攻击者很清楚栈结构（所以溢出时知道怎么构造假的栈帧）、函数/系统调用约定（Calling Convention）</ol><h2 id="为什么-os-不主动防止-buffer-overflow">为什么 OS 不主动防止 buffer overflow？</h2><p>因为系统（软件部分）不可能事无巨细、面面俱到，overflow 行为发生在完全属于程序自己的内存空间；而硬件才是会参与、干预每一项细微操作，因此这类问题可以从硬件角度解决。</p><h2 id="程序如何消除-buffer-overflow-漏洞">程序如何消除 buffer overflow 漏洞？</h2><p>消除漏洞的意思是，从语言和编程入手，让程序本身无漏洞。</p><h3 id="措施-1-c-语言要避免写出-bug甚至避免使用-c">措施 1. c 语言要避免写出 bug，甚至避免使用 c</h3><p>对于 c 这种弱类型语言来说，很难区分 bug 非 bug。随着机器、语言的性能越来越好，很多时候仍然坚持使用 c 是没意义的。</p><h3 id="措施-2-使用工具来找-bug包括">措施 2. 使用工具来找 bug，包括</h3><ol><li>静态分析<li>fuzzing</ol><p>fuzz 本质上是找出隐藏 bug 的分支，普通的功能测试通常无法覆盖所有的分支，静态分析可以和 fuzz 结合（帮助生产 fuzz 用例）</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">z</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span> <span class="c1">//到这里，静态分析工具会提示有问题，offset 未初始化。</span>
    <span class="k">if</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">){</span> <span class="c1">//从静态分析，fuzz 用例可以构造 &lt;7、 =7 、&gt;7 三种情况</span>
        <span class="n">bar</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>以上这些方法都无法完全消除安全 bug</p><h3 id="措施-3-使用内存安全语言-pythonjavac">措施 3. 使用内存安全语言 Python,Java,c#</h3><p>这个方法的局限在于：</p><ul><li>有很多历史遗留代码是 c<li>要在底层操作硬件（驱动程序等等）这个场景需要 c 的好处<li>性能变差（这些语言面世时无一例外都由解释器解释执行，上而不是直接使用 x86指令。即编译成中间码的高层级指令，然后由一个程序 loop 逐一读入指令并执行，例如 JVM 执行指令就是基于对 stack 的 push pop 操作来模拟这些操作）当然解决办法后面也有出来，比如 JIT 编译就是在运行时编译成 x86 指令</ul><p>需要性能的场景：程序是 CPU bound，CPU速度很重要 <br /> 不需要性能的场景：程序是 IO bound，大部分时间都是在等待用户输入、硬盘、网络包等等，这些场景实际并不需要高速的原生计算，</p><h2 id="如果-buffer-overflow-不可避免有什么缓解措施">如果 buffer overflow 不可避免，有什么缓解措施？</h2><ul><li>buffer overflow 的本质<ol><li>获取指令指针（IP）的控制权<li>劫持IP到恶意代码</ol></ul><p>缓解措施着眼于溢出发生时，阻止攻击者进行以下步骤：</p><ul><li><strong>改写代码指针</strong>劫持控制流，例如返回地址，函数指针，C++ vtable， 异常处理句柄<li>在内存中后注入或已存在<strong>恶意代码</strong><li>将恶意代码安置在<strong>可预测位置</strong>，令代码指针指向该位置</ul><h2 id="缓解措施-1-stack-canary">缓解措施 1. Stack Canary</h2><h3 id="canary-如何防范被攻击者绕过">Canary 如何防范被攻击者绕过？</h3><ol><li>使用 0，CR，LF，-1 等特殊字符（攻击者要用这些字符来 overflow 构造 Canary 时，会让被攻击的函数停止，比如 gets 就是 0），当然对于那些不涉及特殊字符终止的场景，就无效了<li>使用随机化的 canary</ol><h3 id="canary-无法防范的场景">Canary 无法防范的场景？</h3><ol><li>指针地址覆盖。因为被践踏的指针地址被代码使用时，并没有 canary 检查，当然如果在每个指针使用前执行检查，那代价昂贵…</ol><p>一个指针覆盖例子：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">...;</span>
<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
<span class="n">gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span> <span class="c1">//Buffer is overflowed, and overwrites ptr.</span>
<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">//Writes to an attacker-controlled address!</span>
<span class="c1">//Canaries can't stop this kind of thing.</span>
</pre></table></code></div></div><p>Canary 起作用的条件 overflow 发生后立即执行检查的场景，典型的就是 ret 前检查 buf。在 return 前执行栈检查指令，需要编译器的帮助，以拓展原来的调用约定 —— 原来是 leave 然后 ret，现在就是在 ret 前插入 canary 相关指令。</p><ol><li><p>随机数被猜测</p><li><p>malloc and free 攻击</p></ol><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre>+----------------+
|                |
|    App data    |
|                |    Allocated memory block
+----------------+
|      size      |
+----------------+


+----------------+
|      size      |
+----------------+

|   ...empty...  |
+----------------+
|     bkwd ptr   |
+----------------+
|     fwd ptr    |    Free memory block
+----------------+
|      size      |
+----------------+ 
</pre></table></code></div></div><p>原理是某块 malloc 的空间发生 overflow 后，可以覆盖相邻块空间的 size 字段，这样当堆管理系统 free 这些空间时，由于有两个 free，会将相邻的两块空闲空间合并：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">p</span> <span class="o">=</span> <span class="n">get_free_block_struct</span><span class="p">(</span><span class="n">size</span><span class="p">);</span><span class="c1">//size 是被控制的，那么 p 也是可以构造的了，也就是下面两个 write 可以被控制来往任意地址写入两个 pointer 长度的数据</span>
<span class="n">bck</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
<span class="n">fwd</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
<span class="n">fwd</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span> <span class="c1">//Writes memory!</span>
<span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">fwd</span><span class="p">;</span> <span class="c1">//Writes memory!</span>
</pre></table></code></div></div><p>（上述过程相当于将空闲 block 的双向链表中某个节点去掉，并重新连通）</p><p>但实际上如果不精心构造，大部分情况都是非法地址写入，产生段错误。</p><h2 id="缓解措施-2-边界检查">缓解措施 2. 边界检查</h2><ul><li>总体目标：</ul><p>通过检查指针是否在边界内来阻止指针误用</p><ul><li>难点：</ul><p>首先 c 语言里面本来就很难判断一个指针本身（指针类型）是否是合法还是非法，同样是 char * 指针，用来访问 string 类型的 char 数组是没问题的，但是如果该 char 数组是网络数据包，那就不行了（显然要用对应结构体的指针）</p><p>更典型的是利用联合体指针访问内存对象，根据实际内存的不同，可能 valid 也可能是 invalid</p><p>造成上述状况的根本原因在于，c 语言中指针本身并不包含使用意图语义。</p><p>所以，要完全解决是很难的，所以退而求其次，我只要求指针访问的内存，是在边界内即可，具体语义是：指针派生的指针，后者只能解引用属于前者的合法的内存区域</p><p>即使是退而求其次，也是很有意义的，能够防止内存的随意覆盖：程序只能践踏实际分配的、属于自己的内存。这已经的 c 语言世界里的一大改进了！</p><h3 id="electric-fences">Electric fences</h3><p>在每个堆对象的边界插一个 guard page，再通过 page tables 来确保对该 page 的访问会立即产生错误。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>+---------+
|  Guard  |
|         |  ^
+---------+  | Overflows cause a page exception
|  Heap   |  |
|  obj    |  |
+---------+
</pre></table></code></div></div><p>也是一种非常好用的 debugg 技术，只要发生 over flow，立即导致 crash 而不是静悄悄或拖到未来才发现。</p><p>最大的优点：使用非常方便。无需修改源代码、无需编译器支持，只要修改 malloc 库函数以实现 Electric fences 就行。<br /> 缺点：耗费空间，特别是存储特别小的堆对象时。所以生产环境很少使用。</p><h3 id="fat-pointers">Fat Pointers</h3><p>思想：修改普通指针，使其除了地址以外，包含首尾边界信息。编译器自动增加额外的代码，使得当访问 fat 指针使其地址更新时，fat 指针的边界也被强制检查</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Plaintext "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>+-----------------+
| 4-byte address  |
+-----------------+

Fat pointer (96 bits)
+-----------------+----------------+---------------------+
| 4-byte obj_base | 4-byte obj_end | 4-byte curr_address |
+-----------------+----------------+---------------------+
</pre></table></code></div></div><p>缺点1：每次指针解引用前都执行边界检查，是一项昂贵的开支，对于 C 语言这种追求性能的语言来说，更是如此。</p><p>缺点2：与现成的大量软件不兼容：</p><ul><li>现成的库未经修改的话，不接受 fat 指针<li>包含 fat 指针的数据结构，sizeof 大小会改变（所以，原来哪些使用硬编码数据结构大小的代码，会出问题）<li>fat 指针的更新不是原子化的，而有些程序假设指针写入是原子化的。fat 指针不再是 1 word，而含是多个 word（在 32bit 机器上，32bit 即 1 word 写入是原子化的），其更新操作包含多个步骤。</ul><p>同样的，有令人恶心的副作用，所以生成环境也少用。</p><h3 id="使用-shadow-data-structures-来跟踪边界信息">使用 shadow data structures 来跟踪边界信息</h3><blockquote><p>论文：Use shadow data structures to keep track of bounds information (Jones and Kelly, Baggy).</p></blockquote><h4 id="基本思想">基本思想</h4><p>对于每一个分配的对象，同时额外地（使用 shadow data structure）存储该对象的大小信息。举例：存储 malloc 时传递的大小值：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">mem_size</span><span class="p">);</span>
</pre></table></code></div></div><p>对于大小值是静态的，值由编译器确定：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span text-data=" C "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">char</span> <span class="n">p</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
</pre></table></code></div></div><p>然后，对于这样的每个指针，干预两个操作来实现边界检查。</p><ul><li>指针运算： <code class="language-plaintext highlighter-rouge">char *q = p + 256</code><li>指针解引用： <code class="language-plaintext highlighter-rouge">char ch = *q;</code></ul><p>为什么一定要两个操作都干预，只使用某一项不行吗？在指针运算判断的非法指针不一定都是 bug，比如所谓的 “哨兵” 指针（比如数组的最后一项 +1 项），可以用来作为循环终止条件，所以这时候就需要干预解引用了；而指针解引用则是要依赖指针运算阶段获取到 OOB （out of bound）位，没有 OOB 以及当前指针所在的位置，那么解引用时是否越界也就无从判断了。</p><h4 id="如何实现">如何实现？</h4><p>挑战 1：怎么存储边界信息呢？即指针地址 -&gt; 边界信息 这个映射关系。效率是一个重要问题。</p><ul><li><p>简单方案 1：使用哈希表或者树，存储映射关系。好处：节省空间（只存使用中的指针，而不是所有可能的指针）；坏处：寻找速度慢（每次查找需要访问多处内存，即使是 Hash 表，也有溢出） 注：Jones and Kelly, Baggy 的<a href="https://github.com/YuZhang/Security-Courseware/blob/master/buffer-overflow/supplements/baggy-bound-checking-USENIX2009.pdf">论文</a>就提出了一种非常高效的数据结构，来跟踪这些边界信息，使得边界检查变得非常快。</p><li><p>简单方案 2：使用数组来存储每个内存地址的边界信息，速度快但占用内存。</p></ul><p>挑战 2：如何强制 OOB 指针解引用失败？</p><ul><li>简单方案：检测每个指针解引用，优点，可行，缺点是很高的内存消耗</ul><p>后面介绍了 <a href="https://www.usenix.org/legacy/events/sec09/tech/full_papers/akritidis.pdf">宽松边界检查（Baggy Bounds Checking）</a> 的原理，简单说就通过引入一种新的内存分配机制，使得指针边界计算、边界信息存储（通过数组）、边界信息索引变得非常高效，并且利用 VM（虚拟内存）系统自身的内存保护特性，把要解引用的非法指针的关键 bit 设置到非法内存区域，让 paging 硬件报错，这样就不用对解引用采取额外的阻断操作了。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/mit-6-858/'>MIT 6.858</a>, <a href='/categories/course/'>Course</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=MIT 6.858 Course 2 - Control Hijacking Attacks - Hongbo Lin&url=https://linhongbo.com/posts/mit-6858-course-2-control-hijacking-attacks/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=MIT 6.858 Course 2 - Control Hijacking Attacks - Hongbo Lin&u=https://linhongbo.com/posts/mit-6858-course-2-control-hijacking-attacks/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=MIT 6.858 Course 2 - Control Hijacking Attacks - Hongbo Lin&url=https://linhongbo.com/posts/mit-6858-course-2-control-hijacking-attacks/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/aosp-repo-guide/">使用 Repo 下载 AOSP 源代码</a><li><a href="/posts/shadowsocks-on-openwrt/">OpenWrt Shadowsocks 安装&配置指南</a><li><a href="/posts/how-to-use-clash-on-openwrt/">OpenWrt 下安装和使用 Clash (ShellCrash)</a><li><a href="/posts/openwrt-usual-configuration/">OpenWrt 常用网络配置</a><li><a href="/posts/shadowsocks-server-on-openwrt/">OpenWrt 安装 Shadowsocks Server</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/openwrt/">OpenWrt</a> <a class="post-tag" href="/tags/shadowsocks/">Shadowsocks</a> <a class="post-tag" href="/tags/nas/">NAS</a> <a class="post-tag" href="/tags/dexguard/">DexGuard</a> <a class="post-tag" href="/tags/apache/">Apache</a> <a class="post-tag" href="/tags/chromium/">Chromium</a> <a class="post-tag" href="/tags/clash/">Clash</a> <a class="post-tag" href="/tags/compiler/">Compiler</a> <a class="post-tag" href="/tags/ddns/">DDNS</a> <a class="post-tag" href="/tags/esxi/">ESXi</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/mit-6858-course-1-introduction-threat-models/"><div class="card-body"> <span class="timeago small" >Nov 25, 2021<i class="unloaded">2021-11-25T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MIT 6.858 Course 1 - Introduction, Threat Models</h3><div class="text-muted small"><p> 安全分为 Policy、Threat Model、Mechanism 三部分。 Policy 错误例子：Gmail 的密码重置需要辅助邮箱，辅助邮箱提供商的邮箱重置有问题，导致Gmail 不行。 Threat Model：对攻击者的假设（assumption）。比如对于web服务器，假设就是攻击者无法物理接触，但可以发送任何规格的数据包。错误例子：在 80 年代 Mit Kerberos...</p></div></div></a></div><div class="card"> <a href="/posts/mit-6858-course-3-buffer-overflow-exploits-and-defenses/"><div class="card-body"> <span class="timeago small" >Nov 26, 2021<i class="unloaded">2021-11-26T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MIT 6.858 Course 3 - Buffer Overflow Exploits and Defenses</h3><div class="text-muted small"><p> buffer overflow 缓解措施（续上节） 措施 3. 堆栈不可执行， 硬件支持对内存读、写、执行的权限说明。例如，AMD 的 NX 位，Intel 的 XD 位，Windows DEP（Data Execution Prevention），Linux 的 Pax。可将栈标记为不可执行。一些系统强制 「W^X」，即可写和可执行不能同时存在，但也不支持动态生成代码（同时需要写和执行...</p></div></div></a></div><div class="card"> <a href="/posts/mit-6858-lab-1-buffer-overflows/"><div class="card-body"> <span class="timeago small" >Nov 26, 2021<i class="unloaded">2021-11-26T00:00:00+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MIT 6.858 lab 1 - Buffer overflows</h3><div class="text-muted small"><p> zook 代码解读 zookld：负责根据配置启动进程，包括 zookd（Web服务，负责分发），zook http 服务和 zookfs 另外一个服务。zookld 会在 main() 中打开并经监听指定的端口（默认 80，是 Web 服务器对外接口），然后将此端口发给 zookd 使用。 start_server() 起一个 HTTP socket，根据配置...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/mit-6858-course-1-introduction-threat-models/" class="btn btn-outline-primary" prompt="Older"><p>MIT 6.858 Course 1 - Introduction, Threat Models</p></a> <a href="/posts/mit-6858-course-3-buffer-overflow-exploits-and-defenses/" class="btn btn-outline-primary" prompt="Newer"><p>MIT 6.858 Course 3 - Buffer Overflow Exploits and Defenses</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/username">Hongbo Lin</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/openwrt/">OpenWrt</a> <a class="post-tag" href="/tags/shadowsocks/">Shadowsocks</a> <a class="post-tag" href="/tags/nas/">NAS</a> <a class="post-tag" href="/tags/dexguard/">DexGuard</a> <a class="post-tag" href="/tags/apache/">Apache</a> <a class="post-tag" href="/tags/chromium/">Chromium</a> <a class="post-tag" href="/tags/clash/">Clash</a> <a class="post-tag" href="/tags/compiler/">Compiler</a> <a class="post-tag" href="/tags/ddns/">DDNS</a> <a class="post-tag" href="/tags/esxi/">ESXi</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-118658920-3"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-118658920-3'); }); </script>
